// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protos related to a user of the site, whether Google login or Guest.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.21.3
// source: model/user.proto

package model

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A user of this site. If the user used Google login, the google_user
// field will be populated.
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID as stored in the local database.
	Id *int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Data obtained from Google OAuth.
	GoogleUser *GUser `protobuf:"bytes,2,opt,name=google_user,json=googleUser" json:"google_user,omitempty"`
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_model_user_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_model_user_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_model_user_proto_rawDescGZIP(), []int{0}
}

func (x *User) GetId() int64 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

func (x *User) GetGoogleUser() *GUser {
	if x != nil {
		return x.GoogleUser
	}
	return nil
}

// A Google user, based on OpenIDConnect
// https://developers.google.com/identity/protocols/OpenIDConnect
type GUser struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// REQUIRED. Who issued this token. Usually "accounts.google.com"
	Iss *string `protobuf:"bytes,1,opt,name=iss" json:"iss,omitempty"`
	// The client_id of the authorized presenter. This claim is only needed when
	// the party requesting the ID token is not the same as the audience of the
	// ID token. This may be the case at Google for hybrid apps where a web
	// application and Android app have a different client_id but share the same
	// project.
	Azp *string `protobuf:"bytes,2,opt,name=azp" json:"azp,omitempty"`
	// REQUIRED. Identifies the audience that this ID token is intended for. It
	// must be one of the OAuth 2.0 client IDs of your application.
	Aud *string `protobuf:"bytes,3,opt,name=aud" json:"aud,omitempty"`
	// REQUIRED. An identifier for the user, unique among all Google accounts
	// and never reused. A Google account can have multiple emails at different
	// points in time, but the sub value is never changed. Use sub within your
	// application as the unique-identifier key for the user. An integer,
	// sometimes larger than int64.
	Sub *string `protobuf:"bytes,4,opt,name=sub" json:"sub,omitempty"`
	// The user's email address. This may not be unique and is not suitable for
	// use as a primary key. Provided only if your scope included the string
	// "email".
	Email *string `protobuf:"bytes,5,opt,name=email" json:"email,omitempty"`
	// True if the user's e-mail address has been verified; otherwise false.
	EmailVerified *bool `protobuf:"varint,6,opt,name=email_verified,json=emailVerified" json:"email_verified,omitempty"`
	// Access token hash. Provides validation that the access token is tied to
	// the identity token. If the ID token is issued with an access token in the
	// server flow, this is always included. This can be used as an alternate
	// mechanism to protect against cross-site request forgery attacks.
	AtHash *string `protobuf:"bytes,7,opt,name=at_hash,json=atHash" json:"at_hash,omitempty"`
	// The user's full name, in a displayable form. When name claims are
	// present, you can use them to update your app's user records. Note that
	// this claim is never guaranteed to be present.
	Name *string `protobuf:"bytes,8,opt,name=name" json:"name,omitempty"`
	// The URL of the user's profile picture.
	Picture *string `protobuf:"bytes,9,opt,name=picture" json:"picture,omitempty"`
	// The given name of the user.
	GivenName *string `protobuf:"bytes,10,opt,name=given_name,json=givenName" json:"given_name,omitempty"`
	// The family name of the user.
	FamilyName *string `protobuf:"bytes,11,opt,name=family_name,json=familyName" json:"family_name,omitempty"`
	// The user's locale, like "en"
	Locale *string `protobuf:"bytes,12,opt,name=locale" json:"locale,omitempty"`
	// REQUIRED. The time the ID token was issued, represented in Unix time
	// (integer seconds).
	Iat *int64 `protobuf:"varint,13,opt,name=iat" json:"iat,omitempty"`
	// REQUIRED. The time the ID token expires, represented in Unix time
	// (integer seconds).
	Exp *int64 `protobuf:"varint,14,opt,name=exp" json:"exp,omitempty"`
	// Not known, but likely a timestamp for not-before.
	Nbf *int64 `protobuf:"varint,17,opt,name=nbf" json:"nbf,omitempty"`
	// Not known
	Jti *string `protobuf:"bytes,15,opt,name=jti" json:"jti,omitempty"`
	// The hosted G Suite domain of the user. Provided only if the user belongs
	// to a hosted domain.
	Hd *string `protobuf:"bytes,16,opt,name=hd" json:"hd,omitempty"`
}

func (x *GUser) Reset() {
	*x = GUser{}
	if protoimpl.UnsafeEnabled {
		mi := &file_model_user_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GUser) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GUser) ProtoMessage() {}

func (x *GUser) ProtoReflect() protoreflect.Message {
	mi := &file_model_user_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GUser.ProtoReflect.Descriptor instead.
func (*GUser) Descriptor() ([]byte, []int) {
	return file_model_user_proto_rawDescGZIP(), []int{1}
}

func (x *GUser) GetIss() string {
	if x != nil && x.Iss != nil {
		return *x.Iss
	}
	return ""
}

func (x *GUser) GetAzp() string {
	if x != nil && x.Azp != nil {
		return *x.Azp
	}
	return ""
}

func (x *GUser) GetAud() string {
	if x != nil && x.Aud != nil {
		return *x.Aud
	}
	return ""
}

func (x *GUser) GetSub() string {
	if x != nil && x.Sub != nil {
		return *x.Sub
	}
	return ""
}

func (x *GUser) GetEmail() string {
	if x != nil && x.Email != nil {
		return *x.Email
	}
	return ""
}

func (x *GUser) GetEmailVerified() bool {
	if x != nil && x.EmailVerified != nil {
		return *x.EmailVerified
	}
	return false
}

func (x *GUser) GetAtHash() string {
	if x != nil && x.AtHash != nil {
		return *x.AtHash
	}
	return ""
}

func (x *GUser) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *GUser) GetPicture() string {
	if x != nil && x.Picture != nil {
		return *x.Picture
	}
	return ""
}

func (x *GUser) GetGivenName() string {
	if x != nil && x.GivenName != nil {
		return *x.GivenName
	}
	return ""
}

func (x *GUser) GetFamilyName() string {
	if x != nil && x.FamilyName != nil {
		return *x.FamilyName
	}
	return ""
}

func (x *GUser) GetLocale() string {
	if x != nil && x.Locale != nil {
		return *x.Locale
	}
	return ""
}

func (x *GUser) GetIat() int64 {
	if x != nil && x.Iat != nil {
		return *x.Iat
	}
	return 0
}

func (x *GUser) GetExp() int64 {
	if x != nil && x.Exp != nil {
		return *x.Exp
	}
	return 0
}

func (x *GUser) GetNbf() int64 {
	if x != nil && x.Nbf != nil {
		return *x.Nbf
	}
	return 0
}

func (x *GUser) GetJti() string {
	if x != nil && x.Jti != nil {
		return *x.Jti
	}
	return ""
}

func (x *GUser) GetHd() string {
	if x != nil && x.Hd != nil {
		return *x.Hd
	}
	return ""
}

// Represents the type of access that can be granted to the given
// user, entity pair
type AccessType struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Should the user be allowed to read the entity.
	// In the case of a quiz, this allows them to participate.
	ReadAllowed *bool `protobuf:"varint,1,opt,name=read_allowed,json=readAllowed" json:"read_allowed,omitempty"`
	// Should the user be allowed to write to this entity.
	// In the case of a quiz, this allows them to modify questions and act as a quizmaster.
	WriteAllowed *bool `protobuf:"varint,2,opt,name=write_allowed,json=writeAllowed" json:"write_allowed,omitempty"`
}

func (x *AccessType) Reset() {
	*x = AccessType{}
	if protoimpl.UnsafeEnabled {
		mi := &file_model_user_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessType) ProtoMessage() {}

func (x *AccessType) ProtoReflect() protoreflect.Message {
	mi := &file_model_user_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessType.ProtoReflect.Descriptor instead.
func (*AccessType) Descriptor() ([]byte, []int) {
	return file_model_user_proto_rawDescGZIP(), []int{2}
}

func (x *AccessType) GetReadAllowed() bool {
	if x != nil && x.ReadAllowed != nil {
		return *x.ReadAllowed
	}
	return false
}

func (x *AccessType) GetWriteAllowed() bool {
	if x != nil && x.WriteAllowed != nil {
		return *x.WriteAllowed
	}
	return false
}

var File_model_user_proto protoreflect.FileDescriptor

var file_model_user_proto_rawDesc = []byte{
	0x0a, 0x10, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x22, 0x45, 0x0a, 0x04, 0x55, 0x73, 0x65,
	0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69,
	0x64, 0x12, 0x2d, 0x0a, 0x0b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2e, 0x47,
	0x55, 0x73, 0x65, 0x72, 0x52, 0x0a, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x55, 0x73, 0x65, 0x72,
	0x22, 0x83, 0x03, 0x0a, 0x05, 0x47, 0x55, 0x73, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x69, 0x73,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x69, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03,
	0x61, 0x7a, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x61, 0x7a, 0x70, 0x12, 0x10,
	0x0a, 0x03, 0x61, 0x75, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x61, 0x75, 0x64,
	0x12, 0x10, 0x0a, 0x03, 0x73, 0x75, 0x62, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x73,
	0x75, 0x62, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x25, 0x0a, 0x0e, 0x65, 0x6d, 0x61, 0x69,
	0x6c, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0d, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x12,
	0x17, 0x0a, 0x07, 0x61, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x06, 0x61, 0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07,
	0x70, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70,
	0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x5f,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x67, 0x69, 0x76, 0x65,
	0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x5f,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x66, 0x61, 0x6d, 0x69,
	0x6c, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x12, 0x10,
	0x0a, 0x03, 0x69, 0x61, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x69, 0x61, 0x74,
	0x12, 0x10, 0x0a, 0x03, 0x65, 0x78, 0x70, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x65,
	0x78, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x6e, 0x62, 0x66, 0x18, 0x11, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x03, 0x6e, 0x62, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x6a, 0x74, 0x69, 0x18, 0x0f, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6a, 0x74, 0x69, 0x12, 0x0e, 0x0a, 0x02, 0x68, 0x64, 0x18, 0x10, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x68, 0x64, 0x22, 0x54, 0x0a, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x61, 0x6c, 0x6c,
	0x6f, 0x77, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x72, 0x65, 0x61, 0x64,
	0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x72, 0x69, 0x74, 0x65,
	0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c,
	0x77, 0x72, 0x69, 0x74, 0x65, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x42, 0x10, 0x5a, 0x0e,
	0x71, 0x75, 0x69, 0x7a, 0x64, 0x72, 0x75, 0x6d, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6c,
}

var (
	file_model_user_proto_rawDescOnce sync.Once
	file_model_user_proto_rawDescData = file_model_user_proto_rawDesc
)

func file_model_user_proto_rawDescGZIP() []byte {
	file_model_user_proto_rawDescOnce.Do(func() {
		file_model_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_model_user_proto_rawDescData)
	})
	return file_model_user_proto_rawDescData
}

var file_model_user_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_model_user_proto_goTypes = []interface{}{
	(*User)(nil),       // 0: model.User
	(*GUser)(nil),      // 1: model.GUser
	(*AccessType)(nil), // 2: model.AccessType
}
var file_model_user_proto_depIdxs = []int32{
	1, // 0: model.User.google_user:type_name -> model.GUser
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_model_user_proto_init() }
func file_model_user_proto_init() {
	if File_model_user_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_model_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_model_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GUser); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_model_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessType); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_model_user_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_model_user_proto_goTypes,
		DependencyIndexes: file_model_user_proto_depIdxs,
		MessageInfos:      file_model_user_proto_msgTypes,
	}.Build()
	File_model_user_proto = out.File
	file_model_user_proto_rawDesc = nil
	file_model_user_proto_goTypes = nil
	file_model_user_proto_depIdxs = nil
}
